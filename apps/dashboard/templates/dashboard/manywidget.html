
{% load static %}
<script src="https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js"></script>
<link href="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/css/select2.min.css" rel="stylesheet" />
<script src="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/js/select2.min.js"></script>
<link rel="stylesheet" type="text/css" href="{% static 'css/manywidget.css' %}"/>
<div class="widget-container">
  {% comment %} Use this hidden input so that Django has a form element at which to get the value {% endcomment %}
  <input name="{{ widget.name }}" style="display:none"/>
  <div class="widget-option-wrapper">
    <select class="widget-select"{% include "django/forms/widgets/attrs.html" %} >
      {% for group_name, group_choices, group_index in widget.optgroups %}
        {% if group_name %}<optgroup label="{{ group_name }}">{% endif %}
          {% for option in group_choices %}
            {% include option.template_name with widget=option %}
          {% endfor %}
        {% if group_name %}</optgroup>{% endif %}
      {% endfor %}
    </select>
  </div>
  <div class="widget-value-list">
    <div id="values-{{ widget.name }}" class="widget-value-list-inner">
     
    </div>
  </div>
</div>
<script>
  // Wrap each widget's script in a function to prevent scope overlap with other widgets
  function {{ widget.name }}_render() {
    const widgetName = "{{ widget.name }}";
    const orderAttr = "{{ widget.order_attr }}"

  const initialValue = 
  [{% for value, title, through_values in widget.value %}
    ["{{value}}","{{title}}", JSON.parse("{{ through_values }}".replace(/&quot;/ig,'"'))],
  {% endfor %}]
  let fieldValue = initialValue
  
  const valueElement = $(`input[name='${widgetName}']`)

  const selectElement = $(`.widget-select#id_${widgetName}`)

  function generateValueBlock(instanceId, instanceTitle, throughValues, index) {
    return `<div class="widget-value-block ${throughValues ? "widget-value-new" : ""} {% if widget.order_input %} block-draggable {% endif %}">
      {% if widget.order_input %}<input type="number" class="widget-value-order order-${widgetName}" value="${index}"></input> {% endif %}
      <div class="widget-value-data-${widgetName}" value="${instanceId}" >${instanceTitle}</div>
      {% for field in widget.additional_fields %} <input class="widget-value-additional-${widgetName}" id="{{field.attr_name}}-${index}" value='${throughValues['{{field.attr_name}}'] || ""}' placeholder="{{field.placeholder}}"></input> {% endfor %}
      <div class="widget-value-remove widget-value-remove-${widgetName}"> x </div>
    </div>`
  }

  function onFieldValueChange(){
    const updatedComponents = fieldValue.map(([instanceId, instanceTitle, throughValues], index)=>
      generateValueBlock(instanceId, instanceTitle, throughValues, index)
    )
    $(`#values-${widgetName}`).html(updatedComponents)
    valueElement.attr("value", JSON.stringify(fieldValue))
  }

  onFieldValueChange()

  // Given a value pair (array formatted [id, text]), finds its index in fieldValues and returns -1 if it's not there
  function indexOfValue(value, array=fieldValue){
    for (let i = 0; i<array.length;i++){
      const currValuePair = array[i]
      if (currValuePair[0] == value[0]){
        return i
      }
    }
    return -1;
  }

  function addValue(value){
    if (indexOfValue(value) == -1) {
      const initialIndex =indexOfValue(value, initialValue)
      // If this instance previously belonged to the model, fetch its previous values instead of creating a new through table instance
      if (initialIndex != -1) {
        value = initialValue[initialIndex]
      } else {
        // if this value didn't previously belong to the model, it won't have the third entry of the value list containing the through table attributes, so add it
        value.push({})
      }
      if (orderAttr && orderAttr != "None") { 
        value[2][orderAttr] = fieldValue.length
      }
      fieldValue.push(value)
      onFieldValueChange()
    }
    selectElement.val(null).trigger('change');
    // TODO: figure out way to hide value from dropdown upon adding it
  }

  function removeValue(valueId){
    fieldValue = fieldValue.filter((entry)=>entry[0]!=valueId)
    onFieldValueChange()
  }

  // Function from here: https://stackoverflow.com/a/5306832
  function moveValue(old_index, new_index) {
    if (new_index < fieldValue.length && new_index >= 0){
      if (new_index >= fieldValue.length) {
        var k = new_index - fieldValue.length + 1;
        while (k--) {
            fieldValue.push(undefined);
        }
      }
      fieldValue.splice(new_index, 0, fieldValue.splice(old_index, 1)[0]);
    }
    
    if (orderAttr && orderAttr !="None") {
      fieldValue[new_index][2][orderAttr] = new_index
    }    
    
    onFieldValueChange()
  };
  
  function editAdditional(fieldName, index, newValue) {
    fieldValue[index][2][fieldName] = newValue
    onFieldValueChange()
  }

  const sortElement = document.getElementById(`values-${widgetName}`);
  
  {% if widget.order_input %}
  const sortable = Sortable.create(sortElement, {
    animation:100,
    onEnd:(evt)=>{
      moveValue(evt.oldDraggableIndex, evt.newDraggableIndex)
    }
  }) 
  {% endif %}

  selectElement.select2({
    placeholder:"Type to search",
    closeOnSelect:false
  })

  // Called when a value is selected
  selectElement.on("select2:select",(event)=>{
    const selectedData = event.params.data
    const selectedValue = selectedData.id
    const selectedText = selectedData.text
    addValue([selectedValue, selectedText])  
  })

  // When you click a remove element, remove the according value
  $(document).on("click",`.widget-value-remove-${widgetName}`,((event)=>{
    const targetElement = $(event.currentTarget).siblings(`.widget-value-data-${widgetName}`)
    const removedValue = targetElement.attr("value")
    const removedText = targetElement.text()
    removeValue(removedValue)
    // Adds the removed value back into the options if it's not already there (ie with pre-existing values)
    if (selectElement.find(`option[value='${removedValue}']`).length == 0) {
      const newOption = new Option(removedText, removedValue, false, false);
      selectElement.append(newOption)
    }
  }))
  // Once you're done editing an order input and click off, update the order
  $(document).on("blur",`.order-${widgetName}`,(event)=>{
    const targetElement = $(event.currentTarget)
    moveValue(Number(targetElement.attr("value")),Number(targetElement.val()))
  })
  $(document).on("change", `.widget-value-additional-${widgetName}`, (event)=>{
    const targetElement = $(event.currentTarget)
    const [additionalField, index] = targetElement.attr("id").split("-")
    editAdditional(additionalField, index,targetElement.val())
  })
  }

  
  {{ widget.name }}_render()

  
</script> 
